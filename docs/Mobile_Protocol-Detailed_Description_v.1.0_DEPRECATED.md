# Mobile Protocol: Detailed Description (v.1.0, DEPRECATED)
> This document describes MTProto v.1.0, and its status is DEPRECATED. For the latest encryption information used by Telegram clients, see [MTProto 2.0](https://core.telegram.org/mtproto/description).

Before using the transport protocol to transmit a message (or multipart messages assembled into a container message) over the network, the message is encrypted in a specific way and an external header is added to the top of the message: a 64-bit secret A key identifier (authorization key that uniquely identifies the server and user) and a 128-bit message key.

The user key and message key together define an actual 256-bit key and a 256-bit initialization vector. Messages are encrypted using AES-256 from IGE. Note that the message header to be encrypted contains variable data (session, message ID, sequence number, server salt) that significantly affects the message key (as well as the AES key and iv). The message key is defined as the lower 128 bits of the SHA1 of the message body (including session, message ID, etc.). Multipart messages are encrypted into a single message.

![mtp v.1.0](./image/mtp-001.png)

## Term

### Authorization Key

The 2048-bit key shared by the client device and the server is created by the user when registering on the client device. It is exchanged through the Diffie-Hellman key and is not transmitted over the network. Each authorization key belongs to a certain user. A user can have multiple keys (multi-terminal synchronization can be implemented). If the device is lost, the server will permanently lock the key. See Creating [construction license key](https://core.telegram.org/mtproto/auth_key)

### Server Key

The server has a 2048-bit RSA key, which is only used to generate an authorization key during registration. The client has a built-in public key that the client can use to verify the signature. The private key is stored on the server and rarely changes.

> Note: The client will use this key for encryption during the handshake phase `new_nonce`!

### Key Identifier

The lower 64 bits of the SHA1 hash of the authorization key are used to indicate which specific key is used to encrypt the message. The key must be uniquely defined by the lower 64 bits of its SHA1 and regenerate the authorization key in the event of a conflict. A key identifier of 0 means that this message is an unencrypted message.

### Session

A 64-bit random number generated by the client to distinguish between sessions (for example, between different instances of an application created with the same authorization key). The session together `auth_key_id` corresponds to an application instance. The server maintains session state to ensure that under no circumstances can messages from one session be sent to different sessions. The client can handle some extreme situations (such as limited server resources,server crash, etc.) The server may forget or discard any client sessions.

### Server Salt

Periodically (for example, every 24 hours) a random 64-bit number that changes based on server requests (based on each session). All subsequent messages must include the new salt (though messages from the old salt can still accept 300 seconds). Primarily used to prevent replay attacks and certain tricks related to adjusting the client clock in the near future.

### Message Identifier (msg_id)

A (time-dependent) 64-bit number that uniquely identifies a message within a session. The client's message `msg_id` is divisible by 4. If it is a response message from the server to the client, the `msg_id` % 4 value of the server is 1, and the non-client response is 3. The client `msg_id` must be monotonically increasing (in a single Session) and, like the server message identifier, must be approximately equal to unixtime * 2 ^ 32. This `msg_id` is about the same time as when the message was created. A message is rejected 300 seconds after creation or 30 seconds before creation (this is necessary to prevent replay attacks. In the case of rejection, a different one must be resent`msg_id`(or placed in a `msg_id` higher container). The container `msg_id` must be strictly larger than the identifier of its nested message.

> Important: To prevent replay attacks, the lower 32 bits of the `msg_id` passed by the client cannot be empty, and the decimal part of the time point must be displayed when the message is created. In the near future, the server will begin to ignore messages where the lower 32 bits of `msg_id` contain too many zeros.

### Content-related Message 

Need to clear the ack message. Including all users and many service messages, almost all messages are messages required by the container and ack.

### Message Sequence Number (msg_seqno)

A 32-bit number equals twice the number of "content-related" messages that the sender created before the message (those that require confirmation, especially those that are not containers), and if the current message is a content-related message . A container is always generated after its entire content; therefore,its serial number is greater than or equal to the serial number of the message contained in it.

### Message Key

The lower 128 bits of SHA1 of the part of the message to be encrypted (including the internal header, not including the aligned bytes).

### Internal (cryptographic) Header

16-byte internal message header, (consisting of server_salts + session_id)

### External (cryptographic) Header

24-byte external message header (composed of auth_key_id + msg_key)

### Payload

External header + encrypted message or container.

## Defining AES Key and Initialization Vector

A 2048-bit Authorization Key (auth_key) and a 128-bit Message Key (msg_key) are used to calculate a 256-bit AES key (aes_key) and a 256-bit initialization vector (aes_iv) .They It is then used to encrypt the message body part of the protocol packet (for example, all other parts except the external header), and the encryption mode is the IGE (Infinite Garble Extension) mode.

Calculate `aes_key`, `aes_iv` from `auth_key` and `msg_key`, the calculation method is as follows:

  - `msg_key = substr (SHA1 (plaintext), 4, 16)`;
  - `sha1_a = SHA1 (msg_key + substr (auth_key, x, 32))`;
  - `sha1_b = SHA1 (substr (auth_key, 32+x, 16) + msg_key + substr (auth_key, 48+x, 16))`;
  - `sha1_с = SHA1 (substr (auth_key, 64+x, 32) + msg_key)`;
  - `sha1_d = SHA1 (msg_key + substr (auth_key, 96+x, 32))`;
  - `aes_key = substr (sha1_a, 0, 8) + substr (sha1_b, 8, 12) + substr (sha1_c, 4, 12)`;
  - `aes_iv = substr (sha1_a, 8, 12) + substr (sha1_b, 0, 8) + substr (sha1_c, 16, 4) + substr (sha1_d, 0, 8)`;

Where `x` = 0, the message is a client-to-server message (Client -> Server), and `x` = 8 is a server-to-client message (Server -> Client). The lower 1024 bits of `auth_key` do not involve encryption in the calculation They can be used by client devices to encrypt local data received from the server.The lower 512 bits of `auth_key` are not stored on the server; therefore, if the client device uses them to encrypt local data, and the user loses the secret key or password, Data cannot be decrypted (even if data can be obtained from the server)

When AES is used to encrypt a data block that is not divisible by 16, before the data is encrypted, the length of the entire data block must be rounded to an integer multiple of 16.

## Important Tests

When an encrypted message is received, `msg_key` the lower 128 bits of the SHA1 hash that is actually equal to the previously encrypted part must be checked ,and `msg_id` there is even parity for messages from the client to the server, and odd parity is used from the server to the client Side news.

In addition, the identifier (`msg_id`) of the last N messages received from the other party must be stored , and if the message comes in less than all or equal to any stored value `msg_id`, the message will be ignored. Otherwise, new messages `msg_id` are added to the collection, and if `msg_id` the number of stored values ​​is greater than N, the oldest (that is, the lowest) is forgotten.

In addition, `msg_id` values ​​belonging to more than 30 seconds or more than 300 seconds in the future will be ignored. This is especially important for servers. The client will also find this useful (to prevent replay attacks), but only if it is a certain time (for example, if its time is already synchronized with the server's time).

Some client-to-server service messages that contain data sent by the client to the server (for example, recent client queries `msg_id`) may be processed on the client even if the time appears to be "incorrect." This is especially true for messages that change `server_salt` and invalid client time notifications. See Mobile Protocol: [Service Message](https://core.telegram.org/mtproto/service_messages).

## Storing an Authorization Key on a Client Device

Users can be advised to pay attention to security issues, and password-protect the key in almost the same way as SSH. This is by adding the SHA1 of the secret key to the front of the Key, and then the entire string is encrypted using the CBC mode of AES, and then an equal to the user's password Key. When the user enters the password, the stored protection password is decrypted and verified by comparison with SHA1. From the user's perspective, this is actually the same as using an application or a Web site password.

## Unencrypted Message

Special plain text messages can be used to create authorization keys and perform time synchronization. When `auth_key_id` = 0 (64-bit) is yes, it means that there is no `auth_key`. In this case, the message body is directly followed by the serial number format, without internal or External header. A message identifier (message Identifier 64-bit) and message body byte length (32 bytes) are added before the message body.

Only a few special types of messages can be transmitted in clear text.

## Schematic Presentation of Messages

### Encrypted Message
| `auth_key_id` | `msg_key` | `encrypted_data` |
|:-:|:-:|:-:|
| int64 | int128 | bytes |

Encrypted data structure:

| `auth_key_id` | `session_id` | `message_id ` | `seq_no` |`message_data_length` |`message_data` | `padding 0..15` |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| int64 | int64 | int64 | int32 | int32 | bytes | bytes |

### Unencrypted Message

| `auth_key_id` | `message_id ` | `message_data_length` |`message_data` |
|:-:|:-:|:-:|:-:|
| int64(value is 0) | int64 | int64 | bytes |

## Create Authorization Key

The Authorization Key is automatically generated when the client application is installed. The registration process occurs after the Authorization Key is generated. The user is prompted to complete the registration form, and the Authorization Key is generated in the background.

The interval entered by the user's keyboard is used to generate a high-quality source of entropy, and the random number is used to create the Authorization Key.

During the Authorization Key creation process, the client obtains its server salt for all communication with the new key in the future. The client then uses the newly generated key to create an encrypted session, and subsequently The communication is in this session (including the transmission of user registration information, phone number verification), unless the client creates a new session. The client can create at any time by selecting a new random session ID (`session_id`) New or additional sessions (multiple application instances need to create different sessions).

